pos.adb:36:10: rule violation: positional parameter association
36 |    T.E1 (10, 11);                       --  FLAG (2)
   |          ^^

pos.adb:36:14: rule violation: positional parameter association
36 |    T.E1 (10, 11);                       --  FLAG (2)
   |              ^^

pos.adb:37:17: rule violation: positional parameter association
37 |    T.E2 (True) (10, 11);                --  FLAG (2)
   |                 ^^

pos.adb:37:21: rule violation: positional parameter association
37 |    T.E2 (True) (10, 11);                --  FLAG (2)
   |                     ^^

pos.adb:40:10: rule violation: positional parameter association
40 |    T.E4 (10, 11);                       --  FLAG (2)
   |          ^^

pos.adb:40:14: rule violation: positional parameter association
40 |    T.E4 (10, 11);                       --  FLAG (2)
   |              ^^

pos.adb:44:15: rule violation: positional parameter association
44 |    I := Fun2 (J, K);                    --  FLAG (2)
   |               ^

pos.adb:44:18: rule violation: positional parameter association
44 |    I := Fun2 (J, K);                    --  FLAG (2)
   |                  ^

pos.adb:52:11: rule violation: positional parameter association
52 |    Proc3 (I);                           --  FLAG
   |           ^

pos.adb:54:11: rule violation: positional parameter association
54 |    Proc4 (1, Y => 2);                   -- FLAG
   |           ^

pos.adb:63:19: rule violation: positional parameter association
63 |    Var_T.T_Proc3 (10);                  --  FLAG
   |                   ^^

Patched "pos.adb":
==================

with Pack; use Pack;

procedure Pos is
   I, J, K : Integer := 1;
   A, B, C : Boolean := True;

   F : Float;

   Var_T : Tagged_T := Tagged_T'(null record);

   procedure Proc1 (I : Integer) with Import;
   procedure Proc2 (I : Integer; B : Boolean := True) with Import;
   procedure Proc3 (X, Y : Integer := 0) with Import;
   procedure Proc4 (X : Integer; Y, Z : Integer := 0) with Import;
   procedure Proc5 (X : Integer; Y : Integer := 0) with Import;

   function Fun1 (I : Integer) return Integer with Import;
   function Fun2 (I : Integer; J : Integer) return Integer with Import;
   function Fun2_Default (I : Integer; J : Integer := 1) return Integer
     with Import;

begin

   --  Calls to operator functions, not flagged
   I := J + K;                          --  NOFLAG
   I := "abs" (K);                      --  NOFLAG
   I := "*" (J, Right => K);            --  NOFLAG

   A := not B and (C or (A xor B));     --  NOFLAG
   B := "not" (C);                      --  NOFLAG

   --  Call to attribute function, not flagged
   K := Integer'Max (I, J);             --  NOFLAG

   --  Entry call
   T.E1 (I=>10, J=>11);                       --  FLAG (2)
   T.E2 (True) (I=>10, J=>11);                --  FLAG (2)
   T.E3 (True);                         --  NOFLAG
   T.E4 (10);                           --  NOFLAG
   T.E4 (I=>10, J=>11);                       --  FLAG (2)

   --  Function calls
   I := Fun1 (J);                       --  NOFLAG because ALL is not set
   I := Fun2 (I=>J, J=>K);                    --  FLAG (2)
   I := Fun2_Default (J);               --  NOFLAG
   I := Fun2 (I => 1, J => 2);          --  NOFLAG

   --  Procedure calls
   Proc1 (I);                           --  NOFLAG because ALL is not set
   Proc2 (I);                           --  NOFLAG
   Proc2 (I => 1, B => A);              --  NOFLAG
   Proc3 (X=>I);                           --  FLAG
   Proc4 (1);                           -- NOFLAG
   Proc4 (X=>1, Y => 2);                   -- FLAG
   Proc5 (1);                           -- NOFLAG

   --  Prefix notation
   Var_T.T_Proc1;                       --  NOFLAG

   Var_T.T_Proc2 (12);                  --  NOFLAG because ALL is not set
   Var_T.T_Proc2 (Y => 10);             --  NOFLAG

   Var_T.T_Proc3 (Y=>10);                  --  FLAG
   Var_T.T_Proc3 (Y => 10);             --  NOFLAG
end Pos;

