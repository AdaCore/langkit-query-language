fun enclosing_package(n) =
    |" Return the first BasePackageDecl enclosing n if any, null otherwise
{
    val packages = [p for p in n?.parents(include_self=false)
                    if p is BasePackageDecl].to_list;
    if packages.length == 0 then null else packages[1]
}

fun is_classwide_type(t) =
    |" Return true if t is a classwide TypeDecl.
    t is ClasswideTypeDecl or
         BaseSubtypeDecl(p_base_subtype() is ClasswideTypeDecl)

fun is_controlling_param_type(t, spec) =
    |" Return true if `t` is a TypeExpr corresponding to a controlling
    |" parameter of the subprogram spec `spec`.
    |" TODO: move this to LAL
    t is TypeExpr(p_designated_type_decl() is d@BaseTypeDecl)
    when ((d?.p_is_tagged_type() and not is_classwide_type(d)) or
          (d is AnonymousTypeDecl and
           d?.p_accessed_type()?.p_is_tagged_type() and
           not is_classwide_type(d?.p_accessed_type())))
     # Check that t is in the same package decl as spec
     and (enclosing_package(t) is p@BasePackageDecl
          when p == enclosing_package(spec))
