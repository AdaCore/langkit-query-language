import stdlib

fun is_class_access(type_decl) =
    |" Given a TypeDecl node, return whether the declared type is an access
    |" to classwide values.
    type_decl.f_type_def is TypeAccessDef(
        f_subtype_indication: *(f_name: AttributeRef(
            f_attribute: Identifier(p_name_is("Class"): true)
        ))
    )

@unit_check(help="prefixes in defining names", remediation="EASY",
            parametric_exemption=true,
            category="Style", subcategory="Readability")
fun identifier_prefixes(
    unit,
    type="-",
    concurrent="-",
    access="-",
    class_access="-",
    subprogram_access="-",
    derived=[],
    constant="-",
    exception="-",
    enum="-",
    exclusive=true
) =
    |" Flag each defining identifier that does not have a prefix corresponding
    |" to the kind of declaration it is defined by. The defining names in the
    |" following kinds of declarations are checked:
    |"
    |" * type and subtype declarations (task, protected and access types are treated
    |"   separately);
    |" * enumeration literal specifications (not including character literals)
    |"   and function renaming declarations if the renaming entity is an
    |"   enumeration literal;
    |" * exception declarations and exception renaming declarations;
    |" * constant and number declarations (including object renaming
    |"   declarations if the renamed object is a constant).
    |"
    |" Defining names declared by single task declarations or single protected
    |" declarations are not checked by this rule.
    |"
    |" The defining name from the full type declaration corresponding to a
    |" private type declaration or a private extension declaration is never
    |" flagged. A defining name from an incomplete type declaration is never
    |" flagged.
    |"
    |" The defining name from a subprogram renaming-as-body declaration is
    |" never flagged.
    |"
    |" For a deferred constant, the defining name in the corresponding full
    |" constant declaration is never flagged.
    |"
    |" The defining name from a body that is a completion of a program unit
    |" declaration or a proper body of a subunit is never flagged.
    |"
    |" The defining name from a body stub that is a completion of a program
    |" unit declaration is never flagged.
    |"
    |" Note that the rule checks only defining names. Usage name occurrence are
    |" not checked and are never flagged.
    |"
    |" The rule may have the following parameters for the ``+R`` option and for LKQL
    |" rule options files:
    |"
    |" *Type: string*
    |"    Specifies the prefix for a type or subtype name.
    |"
    |" *Concurrent: string*
    |"    Specifies the prefix for a task and protected type/subtype name. If this
    |"    parameter is set, it overrides for task and protected types the prefix set by
    |"    the Type parameter.
    |"
    |" *Access: string*
    |"    Specifies the prefix for an access type/subtype name. If this parameter is
    |"    set, it overrides for access types the prefix set by the ``Type``
    |"    parameter.
    |"
    |" *Class_Access: string*
    |"    Specifies the prefix for the name of an access type/subtype that points to some
    |"    class-wide type. If this parameter is set, it overrides for such access types
    |"    and subtypes the prefix set by the ``Type`` or ``Access`` parameter.
    |"
    |" *Subprogram_Access: string*
    |"    Specifies the prefix for the name of an access type/subtype that points to a
    |"    subprogram. If this parameter is set, it overrides for such access
    |"    types/subtypes the prefix set by the ``Type`` or ``Access`` parameter.
    |"
    |" *Derived: string*
    |"    Specifies the prefix for a type that is directly derived from a given type or
    |"    from a subtype thereof. The parameter must have the ``string1:string2`` format
    |"    where *string1* should be a full expanded Ada name of the ancestor type
    |"    (starting from the full expanded compilation unit name) and *string2* defines
    |"    the prefix to check. If this parameter is set, it overrides for types that
    |"    are directly derived from the given type the prefix set by the ``Type``
    |"    parameter.
    |"
    |" *Constant: string*
    |"    Specifies the prefix for defining names from constants and named number
    |"    declarations, including the object renaming declaration if the
    |"    renamed object is a constant
    |"
    |" *Enum: string*
    |"    Specifies the prefix for defining enumeration literals and for the
    |"    defining names in a function renaming declarations if the renamed
    |"    entity is an enumeration literal.
    |"
    |" *Exception: string*
    |"    Specifies the prefix for defining names from exception declarations
    |"    and exception renaming declarations.
    |"
    |" *Exclusive: bool*
    |"    If ``true``, check that only those kinds of names for which specific prefix
    |"    is defined have that prefix (e.g., only type/subtype names have prefix *T_*,
    |"    but not variable or package names), and flag all defining names that have any
    |"    of the specified prefixes but do not belong to the kind of entities this
    |"    prefix is defined for. By default the exclusive check mode is ON.
    |"
    |" You have to use the ``param_name=value`` formatting to pass arguments through
    |" the ``+R`` options. Example: ``+RIdentifier_Prefixes:Type=Type_,Enum=Enum_``.
    |"
    |" The ``+RIdentifier_Prefixes`` option (with no parameter) does not create a new
    |" instance for the rule; thus, it has no effect on the current GNATcheck run.
    |"
    |" There is no default prefix setting for this rule. All checks for
    |" name prefixes are case-sensitive
    |"
    |" If any error is detected in a rule parameter, that parameter is ignored.
    |" In such a case the options that are set for the rule are not specified.
    |"
    |" The rule allows parametric exemption, the parameters that are allowed in
    |" the definition of exemption sections are:
    |"
    |" *Type*
    |"   Exempts check for type and subtype name prefixes
    |"
    |" *Concurrent*
    |"   Exempts check for task and protected type/subtype name prefixes
    |"
    |" *Access*
    |"   Exempts check for access type/subtype name prefixes
    |"
    |" *Class_Access*
    |"   Exempts check for names of access types/subtypes that point to
    |"   some class-wide types
    |"
    |" *Subprogram_Access*
    |"   Exempts check for names of access types/subtypes that point to
    |"   subprograms
    |"
    |" *Derived*
    |"   Exempts check for derived type name prefixes
    |"
    |"
    |" *Constant*
    |"   Exempts check for constant and number name prefixes
    |"
    |" *Exception*
    |"   Exempts check for exception name prefixes
    |"
    |" *Enum*
    |"   Exempts check for enumeration literal name prefixes
    |"
    |" *Exclusive*
    |"   Exempts check that only names of specific kinds of entities have prefixes
    |"   specified for these kinds
    |"
    |" .. rubric:: Example
    |"
    |" .. code-block:: ada
    |"    :emphasize-lines: 4, 7, 10
    |"
    |"    --  if the rule is activated as '+RIdentifier_Prefixes:Type=Type_,Constant=Const_,ExceptioN=X_'
    |"    package Foo is
    |"       type Type_Enum_1 is (A1, B1, C1);
    |"       type Enum_2      is (A2, B2, C2);         --  FLAG
    |"
    |"       Const_C1 : constant Type_Enum_1 := A1;
    |"       Const2   : constant Enum_2      := A2;    --  FLAG
    |"
    |"       X_Exc_1 : exception;
    |"       Exc_2   : exception;                      --  FLAG
    |"    end Foo;
    {
        val str_prefix = " does not start with ";

        fun check_exclusive(
            str,
            type_exclusive=true,
            concurrent_exclusive=true,
            access_exclusive=true,
            class_access_exclusive=true,
            subprogram_access_exclusive=true,
            constant_exclusive=true,
            exception_exclusive=true,
            enum_exclusive=true
        ) =
            exclusive
            and (
                (type_exclusive and str.starts_with(type))
                or (concurrent_exclusive and str.starts_with(concurrent))
                or (access_exclusive and str.starts_with(access))
                or (class_access_exclusive and str.starts_with(class_access))
                or (subprogram_access_exclusive and str.starts_with(subprogram_access))
                or (constant_exclusive and str.starts_with(constant))
                or (exception_exclusive and str.starts_with(exception))
                or (enum_exclusive and str.starts_with(enum))
            );

        fun check_enum(str) =
            if (
                (enum != "-" and not str.starts_with(enum))
                or check_exclusive(str, enum_exclusive=false)
            )
            then str_prefix & "enumeration prefix " & enum
            else ();

        @memoized
        fun get_derived(t) = {
            |" Return the element from derived corresponding to t, if any, or ""
            val name = t.p_canonical_type()
                        .p_canonical_fully_qualified_name();
            val res = [n for n in derived if name == n.split(":")[1]].to_list;
            if not res then "" else res[res.length]
        };

        fun check_prefix(name) =
            |" Given a DefiningName, check that it is validating all expressed
            |" prefix constraints. Returns a string containing the message
            |" explaining the constraint violation if the defining name is
            |" invalid, unit else.
            match name.parent
            # Concurrent types
            | p@(TaskTypeDecl | ProtectedTypeDecl | TaskBody | ProtectedBody
                | SubtypeDecl(p_canonical_type(): TaskTypeDecl | ProtectedTypeDecl))
              when p is not SingleTaskTypeDecl
               and concurrent != "-"
            =>
                if (
                    p.p_previous_part() is (null | IncompleteTypeDecl) and (
                        not name.f_name.text.starts_with(concurrent)
                        or check_exclusive(name.f_name.text, concurrent_exclusive=false)
                    )
                )
                then str_prefix & "concurrent prefix " & concurrent
                else ()

            # 'Class access
            | (
                p@TypeDecl when is_class_access(p)
                | p@SubtypeDecl(
                    p_canonical_type(): td@TypeDecl when is_class_access(td)
                )
            ) when class_access != "-"
            =>
                if (
                    p.p_previous_part() is (null | IncompleteTypeDecl) and (
                        not name.f_name.text.starts_with(class_access)
                        or check_exclusive(name.f_name.text, class_access_exclusive=false)
                    )
                )
                then str_prefix & "access-to-class prefix " & class_access
                else ()

            # Subprogram access
            | (
                p@TypeDecl(f_type_def: AccessToSubpDef)
                | p@SubtypeDecl(
                    p_canonical_type(): TypeDecl(f_type_def: AccessToSubpDef)
                )
            ) when subprogram_access != "-"
            =>
                if (
                    p.p_previous_part() is (null | IncompleteTypeDecl) and (
                        not name.f_name.text.starts_with(subprogram_access)
                        or check_exclusive(name.f_name.text, subprogram_access_exclusive=false)
                    )
                )
                then str_prefix & "access-to-subprogram prefix " & subprogram_access
                else ()

            # Other access types
            | (
                p@TypeDecl(f_type_def: AccessDef)
                | p@SubtypeDecl(
                    p_canonical_type(): TypeDecl(f_type_def: AccessDef)
                )
            ) when access != "-"
            =>
                if (
                    p.p_previous_part() is (null | IncompleteTypeDecl) and (
                        not name.f_name.text.starts_with(access)
                        or check_exclusive(
                            name.f_name.text,
                            access_exclusive=false,
                            # If both an Access prefix and a Type prefix are
                            # set and the type prefix is a prefix of the access
                            # prefix, we don't want to flag this access because
                            # it broke the exclusivity of the type prefix.
                            type_exclusive=false
                        )
                    )
                )
                then str_prefix & "access prefix " & access
                else ()

            # (Sub)Types derived from `derived`
            | p@(TypeDecl(f_type_def: DerivedTypeDef) | SubtypeDecl)
              when derived != []
               and p.p_canonical_type().p_base_type() is t@BaseTypeDecl
                   when get_derived(t) != ""
            => {
                val derived_res = get_derived(p.p_canonical_type().p_base_type());
                if (
                    p.p_previous_part() is (null | IncompleteTypeDecl) and (
                        derived_res != ""
                        and not name.f_name.text.starts_with(derived_res.split(":")[2])
                    )
                )
                then str_prefix & "derived prefix " & derived_res.split(":")[2]
                else ()
            }

            # Exclude IncompleteTypeDecl
            | IncompleteTypeDecl => ()

            # Other types and subtypes
            | p@BaseTypeDecl
              when p is not SingleTaskTypeDecl
            =>
                if (
                    p.p_previous_part() is (null | IncompleteTypeDecl) and (
                        (type != "-" and not name.f_name.text.starts_with(type))
                        or check_exclusive(name.f_name.text, type_exclusive=false)
                    )
                )
                then str_prefix & "subtype prefix " & type
                else ()

            # Enums
            | EnumLiteralDecl => check_enum(name.f_name.text)

            # Look one level up for remaining cases
            | p => match p.parent
                # Constants
                | (
                    ObjectDecl(p_is_constant_object(): true)
                    | NumberDecl
                ) =>
                    if (
                        name.p_previous_part() is null and (
                            (constant != "-" and not name.f_name.text.starts_with(constant))
                            or check_exclusive(name.f_name.text, constant_exclusive=false)
                        )
                    )
                    then str_prefix & "constant prefix " & constant
                    else ()


                # Function renaming an enum literal
                | r@SubpRenamingDecl
                  when r.f_renames?.f_renamed_object?.p_referenced_decl?() is EnumLiteralDecl
                =>
                    check_enum(name.f_name.text)

                # Exceptions
                | ExceptionDecl =>
                    if (
                        (exception != "-" and not name.f_name.text.starts_with(exception))
                        or check_exclusive(name.f_name.text, exception_exclusive=false)
                    )
                    then str_prefix & "exception prefix " & exception
                    else ()

                # Avoid checking declaration completions
                | p@(BodyNode | SubpRenamingDecl | ObjectDecl) => {
                    val n = if p is ObjectDecl then name else p;
                    if n.p_previous_part() is null and check_exclusive(name.f_name.text)
                    then " does not have an exclusive prefix"
                    else ()
                }

                # All other cases, check the exclusivity
                | * =>
                    if check_exclusive(name.f_name.text)
                    then " does not have an exclusive prefix"
                    else ();

        # Iterate over all defining names and check prefixes for each
        [
            {message: s[1].text & s[2], loc: s[1]}
            for s in [
                (n, check_prefix(n))
                for n in from unit.root select DefiningName
            ]
            if s[2] != ()
        ]
    }
