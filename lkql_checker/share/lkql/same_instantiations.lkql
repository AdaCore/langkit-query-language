# Flag each generic package instantiation with the same actual parameters as
# another generic instantiation.

import stdlib

fun same_exprs(e1, e2) =
    match e1
    | IntLiteral    => e2 is IntLiteral and
                       e1.p_denoted_value() == e2.p_denoted_value()
    | CharLiteral   => e2 is CharLiteral and
                       e1.p_denoted_value() == e2.p_denoted_value()
    | StringLiteral => e2 is StringLiteral and
                       e1.p_denoted_value() == e2.p_denoted_value()
    | RealLiteral   => false
    | Name          => e2 is Name and
                       e1.p_referenced_decl() == e2.p_referenced_decl() and
                       not e1.p_is_call()
    | *             => false

fun params_equal(l1, l2, i: int) =
    if i == 0 then true
    else same_exprs(l1[i].f_r_expr, l2[i].f_r_expr) and
         params_equal(l1, l2, i - 1)

fun same_params(p1, p2) = {
    val count = p1.children_count;
    count == p2.children_count and params_equal(p1, p2, count)
}

@unit_check(help="duplicate generic package instantiations")
fun same_instantiations(unit) =
    # For efficiency, we perform a single global scan by only running on the
    # first CompilationUnit.
    if (select first AdaNode) == unit.root then {
    val insts = select GenericPackageInstantiation;

    fun same_instance(node) = {
        val res = [i for i in insts
                   if i != node and
                      node.f_generic_pkg_name.p_referenced_decl() ==
                      i.f_generic_pkg_name.p_referenced_decl() and
                      same_params(node.f_params, i.f_params)].to_list;
        if res.length == 0 then null else res[1]
    };

    [{message: "same instantiation found at " &
               stdlib.sloc_image(same_instance(n)), loc: n}
     for n in insts if same_instance(n) != null]}
    else []
