import stdlib

fun should_be_named(param_assoc, call_expr, check_dot) = {
    val formals = stdlib.get_formals(call_expr.p_called_subp_spec());
    if formals.length > 2 or (formals.length > 1 and not check_dot)
    then {
        val param_defining_name = stdlib.get_parameter(call_expr.p_call_params(), param_assoc.f_r_expr);
        call_expr.f_suffix.children.length > 1
        or stdlib.any([
            {
                val default_expr = formal.param_spec.f_default_expr;
                if formal.name == param_defining_name
                then default_expr != null
                else default_expr == null
            }
            for formal in formals
        ])
    }
    else false
}

fun add_param_name(param, ctx) =
    ctx.set_child(
        param,
        ParamAssoc.f_designator,
        new Identifier(param.p_get_params()[1].text)
    )

@check(message="positional parameter association", remediation="EASY",
       category="Style", subcategory="Programming Practice",
       auto_fix=add_param_name)
fun positional_parameters(node, all=false) =
    |" Flag each positional parameter notation in a subprogram or entry call,
    |" except for the following:
    |"
    |" * Parameters of calls to attribute subprograms are not flagged;
    |" * Parameters of prefix or infix calls to operator functions are not flagged;
    |" * If the called subprogram or entry has only one formal parameter,
    |"   the parameter of the call is not flagged;
    |" * If call expression only carries one actual parameter, corresponding formal
    |"   parameter doesn't have a default value, and all other formal parameters do,
    |"   then the sole actual is not flagged.
    |" * If a subprogram call uses the *Object.Operation* notation, then
    |"   * the first parameter (that is, *Object*) is not flagged;
    |"
    |"   * if the called subprogram has only two parameters, the second parameter
    |"     of the call is not flagged;
    |"
    |" This rule has the following (optional) parameter for the ``+R`` option and
    |" for LKQL rule options files:
    |"
    |" *All: bool*
    |"    If ``true``, all the positional parameter associations that can be replaced
    |"    with named associations according to language rules are flagged, except
    |"    parameters of the calls to operator functions.
    |"
    |" .. rubric:: Example
    |"
    |" .. code-block:: ada
    |"    :emphasize-lines: 17, 21
    |"
    |"    procedure Bar (I : in out Integer) is
    |"       function My_Max (Left, Right : Integer) return Integer renames Integer'Max;
    |"
    |"       procedure Proc1 (I : in out Integer) is
    |"       begin
    |"          I := I + 1;
    |"       end Proc1;
    |"
    |"       procedure Proc2 (I, J : in out Integer) is
    |"       begin
    |"          I := I + J;
    |"       end Proc2;
    |"
    |"       L, M : Integer := 1;
    |"    begin
    |"       Proc1 (L);
    |"       Proc2 (L, M);                              --  FLAG (twice)
    |"       Proc2 (I => M, J => L);
    |"
    |"       L := Integer'Max (10, M);
    |"       M := My_Max (100, Right => L);             --  FLAG
    |"
    |"    end Bar;
    node is ParamAssoc(f_designator: null, parent: l@AssocList)
    when l.parent is c@CallExpr(
        p_is_call(): true,
        f_name: not AttributeRef,
        f_name: id@*(p_is_operator_name(): false) when (
            all or should_be_named(node, c, id.p_is_dot_call())
        )
    )
