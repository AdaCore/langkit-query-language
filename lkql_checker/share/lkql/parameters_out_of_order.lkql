# Flag each formal parameter not ordered according to the specified scheme
# among the following categories:
# - in parameters
# - access parameters
# - in out parameters
# - out parameters
# - in parameters with default initialization expressions
#
# The `order` parameter defines the order required.

fun index(order, str) =
    [n for n in [1, 2, 3, 4, 5] if order[n] == str].to_list[1]

fun priority(spec, order) =
    if spec.f_default_expr != null
    then index(order, "defaulted in")
    else match spec.f_mode
         | ModeOut     => index(order, "out")
         | ModeInOut   => index(order, "in out")
         | ModeIn      => index(order, "in")
         | ModeDefault => if spec.f_type_expr is
                             AnonymousType(f_type_decl is
                                           *(f_type_def is TypeAccessDef))
                          then index(order, "access") else index(order, "in")

@check(message="parameter out of order", remediation="EASY")
fun parameters_out_of_order(node,
                            order = ["in", "access", "in out",
                                     "out", "defaulted in"]) =
    node is ParamSpec when ({
        val prio = priority(node, order);
        node is *(any next_siblings is
                  sib@ParamSpec when priority(sib, order) < prio)
    })
