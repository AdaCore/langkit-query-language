|" LKQL stdlib module
|"
|" This module contains functions that are shared accross lkql_checker rules.
|" All of them should be both:
|"
|" * Candidates for Libadalang integration
|" * Candidates for integration in lkql's stdlib

selector semantic_parent
    |" Return all semantic parent nodes starting from a given node.
    | null     => ()
    | *        => rec this.p_semantic_parent()

selector children_no_nested_subps
    |" Return all children nodes starting from a base subprogram body, but not
    |" entering in nested subprogram bodies.

    | SubpBody =>
        # Don't recurse on subp bodies except if it's the root node (depth == 0)
        rec *(if depth == 0 then this.children else [])
    | null     => ()
    | *        => rec *this.children

fun is_assert_pragma(s) =
    |" Return ``true`` if the string ``s`` is the name of an assert pragma

    s == "assert" or
    s == "assert_and_cut" or
    s == "assume" or
    s == "contract_cases" or
    s == "debug" or
    s == "invariant" or
    s == "loop_invariant" or
    s == "loop_variant" or
    s == "postcondition" or
    s == "precondition" or
    s == "predicate" or
    s == "refined_post"

fun is_assert_aspect(s) =
    |" Return ``true`` if the string ``s`` is the name of an assert aspect

    s == "static_predicate" or
    s == "dynamic_predicate" or
    s == "pre" or
    s == "post" or
    s == "type_invariant" or
    s == "contract_cases" or
    s == "invariant" or
    s == "predicate" or
    s == "refined_post" or
    s == "default_initial_condition" or
    s == "predicate_failure"

fun within_assert(node) =
    |" Return ``true`` if ``node`` is part of an assertion-related pragma or
    |" aspect.
    node is *(any parent is p@Pragma
              when is_assert_pragma(p.f_id?.p_canonical_text()))
    or node is *(any parent is a@AspectAssoc
                 when (match a.f_id
                       | id@Identifier   =>
                           is_assert_aspect(id?.p_canonical_text())
                       | at@AttributeRef =>
                           at?.f_attribute?.p_canonical_text() == "class"
                       | *               => false))

fun ultimate_alias(name, all_nodes=true, strip_component=false) =
    |" Return the ultimately designated `ObjectDecl`, going through renamings
    |" This will not go through generic instantiations. If all_nodes is true,
    |" consider all kinds of nodes, otherwise consider only BaseId and
    |" DottedName. If strip_component is true, go to the prefix when
    |" encountering a component, otherwise stop at the ComponentDecl.

    if all_nodes or name is (BaseId or DottedName) then {
        val decl = name.p_referenced_decl();

        match decl
        | ObjectDecl(f_renaming_clause is r@RenamingClause) =>
            ultimate_alias(r.f_renamed_object, all_nodes, strip_component)
        | ComponentDecl when strip_component and name is DottedName =>
            ultimate_alias(name.f_prefix, all_nodes, strip_component)
        | *                                     => decl
    } else name

fun ultimate_exception_alias(name) =
    |" Return the ultimately designated ``ExceptionDecl``, going through renamings
{
    val decl = name?.p_referenced_decl();

    if decl is ExceptionDecl(f_renames is RenamingClause)
    then ultimate_exception_alias(decl?.f_renames?.f_renamed_object)
    else decl
}

fun ultimate_subprogram_alias(name) =
    |" Return the ultimately designated ``BasicSubpDecl``, going through renamings
    if name is SubpRenamingDecl
    then ultimate_exception_alias(name.f_renames.f_renamed_object.
                                  p_referenced_decl())
    else name

fun has_local_scope(n) =
    |" Return ``true`` if ``n`` is enclosed in a local scope
    n.parent is GenericFormalObjDecl or
    n is *(any semantic_parent is BasicSubpDecl or SubpBody or TaskBody or
                                  BlockStmt or EntryBody or ProtectedBody)

fun is_local_object(o) =
    |" Return ``true`` if ``o`` represents a local ``ObjectDecl`` or ``ParamSpec``
    o is ParamSpec or ObjectDecl when has_local_scope(o)

fun is_in_package_scope(o) =
    |" Return ``true`` if ``o`` is immediately in the scope of a package spec,
    |" body or generic package.
    match o?.parent
    | BasePackageDecl     => true
    | PackageBody         => true
    | SingleTaskDecl      => false
    | TaskTypeDecl        => false
    | TaskBody            => false
    | BlockStmt           => false
    | BaseSubpBody        => false
    | EntryBody           => false
    | SingleProtectedDecl => false
    | ProtectedTypeDecl   => false
    | null                => false
    | *                   => is_in_package_scope(o?.parent)

fun is_program_unit(n) =
    |" Return ``true`` if ``n`` is a program unit spec, body or stub
    n is SubpDecl or AbstractSubpDecl or BaseSubpBody
      or BasePackageDecl or PackageBody or GenericPackageInstantiation
      or GenericDecl or GenericInstantiation
      or SingleTaskDecl or TaskTypeDecl or TaskBody
      or SubpBodyStub or ProtectedBodyStub or PackageBodyStub or TaskBodyStub
      or SingleProtectedDecl or ProtectedTypeDecl

fun is_in_library_unit_body(o) =
    |" Return ``true`` if ``o`` is located in a library unit body
    match o?.parent
    | s@SubpBody    => s?.parent is LibraryItem
    | p@PackageBody => p?.parent is LibraryItem
    | null          => false
    | *             => is_in_library_unit_body(o?.parent)

fun param_pos(n, pos: int = 0) =
    |" Return the position of node ``n`` in its current list of siblings
    if n == null then pos else param_pos(n?.previous_sibling, pos+1)

# TODO: move this in LAL
fun is_predefined_op(op) =
    |" Return true if op is a predefined operator
    op is Op (p_referenced_decl() is null)

fun is_standard_numeric(n) =
    |" Return ``true`` if ``n`` is the name of a numeric type or subtype in Standard
    n == "standard.integer" or
    n == "standard.natural" or
    n == "standard.positive" or
    n == "standard.short_short_integer" or
    n == "standard.short_integer" or
    n == "standard.long_integer" or
    n == "standard.long_long_integer" or
    n == "standard.long_long_long_integer" or
    n == "standard.short_float" or
    n == "standard.float" or
    n == "standard.long_float" or
    n == "standard.long_long_float" or
    n == "standard.duration"

fun is_standard_boolean(n) =
    |" Return true if the root type of n is Standard.Boolean
    n.p_expression_type() is t@BaseTypeDecl
    when t.p_root_type() == n.p_bool_type()

fun is_predefined_type(n) =
    |" Return true if n is the name of a type declared in a predefined package
    |" spec.
{
    # Retrieve the root enclosing package
    # TODO: replace p_full_view() by new LAL API once U915-027 is implemented
    val packages = [
        p for p in n.p_referenced_decl().p_root_type().p_full_view().
                    p_root_type().parents(include_self=false)
        if p is BasePackageDecl
    ].to_list;

    packages.length != 0 and packages[packages.length] is
        BasePackageDecl(f_package_name is
                        DefiningName(p_canonical_part() is name@DefiningName))
        when name.p_name_is("Standard")
          or name.p_name_is("System")
          or name.p_name_is("Ada")
          or name.p_name_is("Interfaces")
}

fun in_generic_template(n) =
    |" Return true if ``n`` is declared as part of a generic template (spec
    |" or body). Return false otherwise, including inside a generic
    |" instantiation.
    n != null and
    n?.p_generic_instantiations().length == 0 and
    ((n is *(any parent is GenericDecl)) or
     n is *(any parent is PackageBody(p_decl_part() is GenericPackageInternal)))

fun enclosing_block(n) =
    |" Return the first DeclBlock enclosing n if any, null otherwise
{
    val blocks = [p for p in n?.parents(include_self=false)
                  if p is DeclBlock].to_list;
    if blocks.length == 0 then null else blocks[1]
}

fun enclosing_body(n) =
    |" Return the first Body enclosing n if any, null otherwise
{
    val bodies = [p for p in n?.parents(include_self=false)
                  if p is Body].to_list;
    if bodies.length == 0 then null else bodies[1]
}

fun enclosing_package(n) =
    |" Return the first BasePackageDecl enclosing n if any, null otherwise
{
    val packages = [p for p in n?.parents(include_self=false)
                    if p is BasePackageDecl].to_list;
    if packages.length == 0 then null else packages[1]
}

fun is_classwide_type(t) =
    |" Return true if t is a classwide TypeDecl.
    |" TODO: move to LAL
    t is ClasswideTypeDecl or
         BaseSubtypeDecl(p_base_subtype() is ClasswideTypeDecl)

fun is_controlling_param_type(t, spec) =
    |" Return true if `t` is a TypeExpr corresponding to a controlling
    |" parameter of the subprogram spec `spec`.
    |" TODO: move this to LAL
    t is TypeExpr(p_designated_type_decl() is d@BaseTypeDecl)
    when ((d?.p_is_tagged_type() and not is_classwide_type(d)) or
          (d is AnonymousTypeDecl and
           d?.p_accessed_type()?.p_is_tagged_type() and
           not is_classwide_type(d?.p_accessed_type())))
     # Check that t is in the same package decl as spec
     and (enclosing_package(t) is p@BasePackageDecl
          when p == enclosing_package(spec))

fun is_constructor(spec) =
    |" Return true if spec is a subprogram spec of a constructor
    |" TODO: move this to LAL?
    is_controlling_param_type(spec?.p_returns(), spec)
     and [p for p in spec?.p_params()
          if is_controlling_param_type(p?.f_type_expr, spec)].length == 0

fun get_subp_body(node) =
    |" Return the SubpBody corresponding to node, if any, null otherwise
    |" TODO: take renamings into account
    match node
    | BaseSubpBody    => node
    | EnumLiteralDecl => null
    | ClassicSubpDecl => node.p_body_part()
    | GenericSubpInstantiation
                      => node.p_designated_generic_decl().p_body_part()
    | SubpBodyStub    => node
    | BasicDecl when node.p_is_subprogram()
                      => node.p_body_part()
    | *               => null

fun sloc_image(node) = {
    |" Return a string with basename:line corresponding to node's sloc
    val tok = node.token_start();
    tok.unit.name.base_name & ":" & img(tok.start_line)
}

fun find_comment(token, name) =
    |" Return true if a comment token immediately following the previous
    |" "begin" keyword is found and containing only the package name.
    if token.kind == "ADA_COMMENT" and
       token.previous.previous.kind == "ADA_BEGIN"
    then token.text.ends_with(name) and
         match token.text.substring(1, token.text.length - name.length)
         | "^-- *$" => true
         | *        => false
    else token.kind != "ADA_BEGIN" and find_comment(token.previous, name)
