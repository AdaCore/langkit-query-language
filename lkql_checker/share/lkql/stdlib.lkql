|" LKQL stdlib module
|"
|" This module contains functions that are shared accross lkql_checker rules.
|" All of them should be both:
|"
|" * Candidates for Libadalang integration
|" * Candidates for integration in lkql's stdlib

fun is_assert_pragma(s) =
    |" Return ``true`` if the string ``s`` is the name of an assert pragma

    s == "assert" or
    s == "assert_and_cut" or
    s == "assume" or
    s == "contract_cases" or
    s == "debug" or
    s == "invariant" or
    s == "loop_invariant" or
    s == "loop_variant" or
    s == "postcondition" or
    s == "precondition" or
    s == "predicate" or
    s == "refined_post"

fun is_assert_aspect(s) =
    |" Return ``true`` if the string ``s`` is the name of an assert aspect

    s == "static_predicate" or
    s == "dynamic_predicate" or
    s == "pre" or
    s == "post" or
    s == "type_invariant" or
    s == "contract_cases" or
    s == "invariant" or
    s == "predicate" or
    s == "refined_post" or
    s == "default_initial_condition" or
    s == "predicate_failure"

fun ultimate_alias(name, all_nodes = true) =
    |" Return the ultimately designated ``ObjectDecl``, going through renamings
    |" This will not go through generic instantiations. If all_nodes is true,
    |" consider all kinds of nodes, otherwise consider only BaseId and
    |" DottedName.
    if all_nodes or name is (BaseId or DottedName) then {
        val decl = name?.p_referenced_decl();

        if decl is ObjectDecl(f_renaming_clause is RenamingClause)
        then ultimate_alias(decl?.f_renaming_clause?.f_renamed_object,
                            all_nodes)
        else decl
    } else name

fun ultimate_exception_alias(name) =
    |" Return the ultimately designated ``ExceptionDecl``, going through renamings
{
    val decl = name?.p_referenced_decl();

    if decl is ExceptionDecl(f_renames is RenamingClause)
    then ultimate_exception_alias(decl?.f_renames?.f_renamed_object)
    else decl
}

fun has_local_scope(n) =
    |" Return ``true`` if ``n`` is enclosed in a local scope
    n is *(any parent is SubpBody or TaskBody or BlockStmt or EntryBody or
                         ProtectedBody or GenericFormalObjDecl)

fun is_local_object(o) =
    |" Return ``true`` if ``o`` represents a local ``ObjectDecl`` or ``ParamSpec``
    o is ParamSpec or ObjectDecl when has_local_scope(o)

fun is_in_package_scope(o) =
    |" Return ``true`` if ``o`` is immediately in the scope of a package spec,
    |" body or generic package.
    match o?.parent
    | BasePackageDecl     => true
    | PackageBody         => true
    | SingleTaskDecl      => false
    | TaskTypeDecl        => false
    | TaskBody            => false
    | BlockStmt           => false
    | BaseSubpBody        => false
    | EntryBody           => false
    | SingleProtectedDecl => false
    | ProtectedTypeDecl   => false
    | null                => false
    | *                   => is_in_package_scope(o?.parent)

fun is_program_unit(n) =
    |" Return ``true`` if ``n`` is a program unit spec, body or stub
    n is SubpDecl or AbstractSubpDecl or BaseSubpBody
      or BasePackageDecl or PackageBody or GenericPackageInstantiation
      or GenericDecl or GenericInstantiation
      or SingleTaskDecl or TaskTypeDecl or TaskBody
      or SubpBodyStub or ProtectedBodyStub or PackageBodyStub or TaskBodyStub
      or SingleProtectedDecl or ProtectedTypeDecl

fun is_in_library_unit_body(o) =
    |" Return ``true`` if ``o`` is located in a library unit body
    match o?.parent
    | s@SubpBody    => s?.parent is LibraryItem
    | p@PackageBody => p?.parent is LibraryItem
    | null          => false
    | *             => is_in_library_unit_body(o?.parent)

fun param_pos(n, pos: int = 0) =
    |" Return the position of node ``n`` in its current list of siblings
    if n == null then pos else param_pos(n?.previous_sibling, pos+1)

# TODO: move this in LAL
fun is_predefined_op(op) =
    |" Return true if op is a predefined operator
    op is Op (p_referenced_decl() is null)

fun is_standard_numeric(n) =
    |" Return ``true`` if ``n`` is the name of a numeric type or subtype in Standard
    n == "standard.integer" or
    n == "standard.natural" or
    n == "standard.positive" or
    n == "standard.short_short_integer" or
    n == "standard.short_integer" or
    n == "standard.long_integer" or
    n == "standard.long_long_integer" or
    n == "standard.long_long_long_integer" or
    n == "standard.short_float" or
    n == "standard.float" or
    n == "standard.long_float" or
    n == "standard.long_long_float" or
    n == "standard.duration"

fun is_standard_boolean(n) =
    |" Return true if the type of n is Standard.Boolean
{
     val typ=n?.p_expression_type();
     typ == null
     or typ?.p_base_subtype()?.p_fully_qualified_name() == "Standard.Boolean"
}

# Return all children nodes starting from a base subprogram body, but not
# entering in nested subprogram bodies.
selector children_no_nested_subps
    | SubpBody =>
        # Don't recurse on subp bodies except if it's the root node (depth == 0)
        rec *(if depth == 0 then this.children else [])
    | null     => ()
    | *        => rec *this.children
