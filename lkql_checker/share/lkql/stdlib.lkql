|" LKQL stdlib module
|"
|" This module contains functions that are shared accross lkql_checker rules.
|" All of them should be both:
|"
|" * Candidates for Libadalang integration
|" * Candidates for integration in lkql's stdlib

fun is_assert_pragma(s) =
    |" Return ``true`` if the string ``s`` is the name of an assert pragma

    s == "assert" or
    s == "assert_and_cut" or
    s == "assume" or
    s == "contract_cases" or
    s == "debug" or
    s == "invariant" or
    s == "loop_invariant" or
    s == "loop_variant" or
    s == "postcondition" or
    s == "precondition" or
    s == "predicate" or
    s == "refined_post"

fun is_assert_aspect(s) =
    |" Return ``true`` if the string ``s`` is the name of an assert aspect

    s == "static_predicate" or
    s == "dynamic_predicate" or
    s == "pre" or
    s == "post" or
    s == "type_invariant" or
    s == "contract_cases" or
    s == "invariant" or
    s == "predicate" or
    s == "refined_post" or
    s == "default_initial_condition" or
    s == "predicate_failure"

fun ultimate_alias(name, all_nodes = true) =
    |" Return the ultimately designated ``ObjectDecl``, going through renamings
    |" This will not go through generic instantiations. If all_nodes is true,
    |" consider all kinds of nodes, otherwise consider only BaseId and
    |" DottedName.
    if all_nodes or name is (BaseId or DottedName) then {
        val decl = name?.p_referenced_decl();

        if decl is ObjectDecl(f_renaming_clause is RenamingClause)
        then ultimate_alias(decl?.f_renaming_clause?.f_renamed_object,
                            all_nodes)
        else decl
    } else name

fun ultimate_exception_alias(name) =
    |" Return the ultimately designated ``ExceptionDecl``, going through renamings
{
    val decl = name?.p_referenced_decl();

    if decl is ExceptionDecl(f_renames is RenamingClause)
    then ultimate_exception_alias(decl?.f_renames?.f_renamed_object)
    else decl
}

fun has_local_scope(n) =
    |" Return ``true`` if ``n`` is enclosed in a local scope
    n is *(any parent is SubpBody or TaskBody or BlockStmt or EntryBody or
                         ProtectedBody or GenericFormalObjDecl)

fun is_local_object(o) =
    |" Return ``true`` if ``o`` represents a local ``ObjectDecl`` or ``ParamSpec``
    o is ParamSpec or ObjectDecl when has_local_scope(o)

fun is_in_package_scope(o) =
    |" Return ``true`` if ``o`` is immediately in the scope of a package spec,
    |" body or generic package.
    match o?.parent
    | BasePackageDecl     => true
    | PackageBody         => true
    | SingleTaskDecl      => false
    | TaskTypeDecl        => false
    | TaskBody            => false
    | BlockStmt           => false
    | BaseSubpBody        => false
    | EntryBody           => false
    | SingleProtectedDecl => false
    | ProtectedTypeDecl   => false
    | null                => false
    | *                   => is_in_package_scope(o?.parent)

fun is_program_unit(n) =
    |" Return ``true`` if ``n`` is a program unit spec, body or stub
    n is SubpDecl or AbstractSubpDecl or BaseSubpBody
      or BasePackageDecl or PackageBody or GenericPackageInstantiation
      or GenericDecl or GenericInstantiation
      or SingleTaskDecl or TaskTypeDecl or TaskBody
      or SubpBodyStub or ProtectedBodyStub or PackageBodyStub or TaskBodyStub
      or SingleProtectedDecl or ProtectedTypeDecl

fun is_in_library_unit_body(o) =
    |" Return ``true`` if ``o`` is located in a library unit body
    match o?.parent
    | s@SubpBody    => s?.parent is LibraryItem
    | p@PackageBody => p?.parent is LibraryItem
    | null          => false
    | *             => is_in_library_unit_body(o?.parent)

fun param_pos(n, pos: int = 0) =
    |" Return the position of node ``n`` in its current list of siblings
    if n == null then pos else param_pos(n?.previous_sibling, pos+1)

# TODO: move this in LAL
fun is_predefined_op(op) =
    |" Return true if op is a predefined operator
    op is Op (p_referenced_decl() is null)

fun is_standard_numeric(n) =
    |" Return ``true`` if ``n`` is the name of a numeric type or subtype in Standard
    n == "standard.integer" or
    n == "standard.natural" or
    n == "standard.positive" or
    n == "standard.short_short_integer" or
    n == "standard.short_integer" or
    n == "standard.long_integer" or
    n == "standard.long_long_integer" or
    n == "standard.long_long_long_integer" or
    n == "standard.short_float" or
    n == "standard.float" or
    n == "standard.long_float" or
    n == "standard.long_long_float" or
    n == "standard.duration"

fun is_standard_boolean(n) =
    |" Return true if the root type of n is Standard.Boolean
    n?.p_expression_type()?.p_root_type() == n?.p_bool_type()

fun is_predefined_type(n) =
    |" Return true if n is the name of a type declared in a predefined package
    |" spec.
{
    # Retrieve the root enclosing package
    val packages = to_list([p for p in n?.p_referenced_decl()?.p_root_type()?.
                                       parents(include_self=false)
                            if p is BasePackageDecl]);
    packages.length != 0 and packages[packages.length] is
        BasePackageDecl(f_package_name is
                        DefiningName(p_canonical_part() is name@DefiningName))
        when name?.p_name_is("Standard")
          or name?.p_name_is("System")
          or name?.p_name_is("Ada")
          or name?.p_name_is("Interfaces")
}

fun in_generic_template(n) =
    |" Return true if ``n`` is declared as part of a generic template (spec
    |" or body). Return false otherwise, including inside a generic
    |" instantiation.
    n?.p_generic_instantiations().length == 0 and
    ((n is *(any parent is GenericDecl)) or
     n is *(any parent is PackageBody(p_decl_part() is GenericPackageInternal)))

fun enclosing_body(n) =
    |" Return the first BaseSubpBody enclosing n if any, null otherwise
{
    val bodies = to_list([p for p in n?.parents(include_self=false)
                          if p is BaseSubpBody]);
    if bodies.length == 0 then null else bodies[1]
}

fun is_classwide_type(t) =
    |" Return true if t is a classwide TypeDecl.
    |" TODO: move to LAL
    t is ClasswideTypeDecl or
         BaseSubtypeDecl(p_base_subtype() is ClasswideTypeDecl)

fun is_controlling_param_type(t) =
    |" Return true if t is a TypeExpr corresponding to a controlling parameter
    |" TODO: move this to LAL
    t is TypeExpr(p_designated_type_decl() is d@BaseTypeDecl)
    when (d?.p_is_tagged_type() and not is_classwide_type(d)) or
         (d is AnonymousTypeDecl and
          d?.p_accessed_type()?.p_is_tagged_type() and
          not is_classwide_type(d?.p_accessed_type()))

# Return all children nodes starting from a base subprogram body, but not
# entering in nested subprogram bodies.
selector children_no_nested_subps
    | SubpBody =>
        # Don't recurse on subp bodies except if it's the root node (depth == 0)
        rec *(if depth == 0 then this.children else [])
    | null     => ()
    | *        => rec *this.children

fun match_wildcard(str, pat) =
    |" Return whether the given string `str` matches the simple wildcard
    |" pattern `pat`. The pattern is an identifier with optionally a
    |" wildcard (`*`) character as the first character, last character or
    |" both.
    match pat
    | "^\*.*\*$" => contains(str, substring(pat, 2, pat.length - 1))
    | "^\*"      => ends_with(str, substring(pat, 2, pat.length))
    | "\*$"      => starts_with(str, substring(pat, 1, pat.length - 1))
    | *          => str == pat
