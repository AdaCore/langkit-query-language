|" LKQL stdlib module
|"
|" This module contains functions that are shared accross lkql_checker rules.
|" These functions may be moved in the future in Libadalang or LKQL's builtin
|" library.

selector semantic_parent
    |" Return all semantic parent nodes starting from a given node.
    | null     => ()
    | *        => rec this.p_semantic_parent()

selector children_no_nested_subps
    |" Return all children nodes starting from a base subprogram body, but not
    |" entering in nested subprogram bodies.

    | SubpBody =>
        # Don't recurse on subp bodies except if it's the root node (depth == 0)
        rec *(if depth == 0 then this.children else [])
    | null     => ()
    | *        => rec *this.children

fun is_assert_pragma(s) =
    |" Return ``true`` if the string ``s`` is the name of an assert pragma

    s == "assert" or
    s == "assert_and_cut" or
    s == "assume" or
    s == "contract_cases" or
    s == "debug" or
    s == "invariant" or
    s == "loop_invariant" or
    s == "loop_variant" or
    s == "postcondition" or
    s == "precondition" or
    s == "predicate" or
    s == "refined_post"

fun is_assert_aspect(s) =
    |" Return ``true`` if the string ``s`` is the name of an assert aspect

    s == "static_predicate" or
    s == "dynamic_predicate" or
    s == "pre" or
    s == "post" or
    s == "type_invariant" or
    s == "contract_cases" or
    s == "invariant" or
    s == "predicate" or
    s == "refined_post" or
    s == "default_initial_condition" or
    s == "predicate_failure"

fun within_assert(node) =
    |" Return ``true`` if ``node`` is part of an assertion-related pragma or
    |" aspect.
    node is *(any parent is
        (p@Pragma when is_assert_pragma(p.f_id?.p_canonical_text()))
     or a@AspectAssoc
        when (match a.f_id
              | id@Identifier   =>
                  is_assert_aspect(id.p_canonical_text())
              | at@AttributeRef =>
                  at.f_attribute?.p_canonical_text() == "class"
              | *               => false))

@memoized
fun ultimate_alias(name, all_nodes=true, strip_component=false) =
    |" Return the ultimately designated `ObjectDecl`, going through renamings
    |" This will not go through generic instantiations. If all_nodes is true,
    |" consider all kinds of nodes, otherwise consider only BaseId and
    |" DottedName. If strip_component is true, go to the prefix when
    |" encountering a component, otherwise stop at the ComponentDecl.

    if all_nodes or name is (BaseId or DottedName) then {
        val decl = name.p_referenced_decl();

        match decl
        | ObjectDecl(f_renaming_clause is r@RenamingClause) =>
            ultimate_alias(r.f_renamed_object, all_nodes, strip_component)
        | ComponentDecl when strip_component and name is DottedName =>
            ultimate_alias(name.f_prefix, all_nodes, strip_component)
        | *                                     => decl
    } else name

@memoized
fun ultimate_exception_alias(name) =
    |" Return the ultimately designated ``ExceptionDecl``, going through renamings
{
    val decl = name.p_referenced_decl();

    if decl is ExceptionDecl(f_renames is RenamingClause)
    then ultimate_exception_alias(decl?.f_renames?.f_renamed_object)
    else decl
}

@memoized
fun ultimate_subprogram_alias(name) =
    |" Return the ultimately designated ``BasicSubpDecl``, going through renamings
    if name is SubpRenamingDecl
    then ultimate_subprogram_alias(name.f_renames.f_renamed_object.
                                   p_referenced_decl())
    else name

@memoized
fun has_local_scope(n) =
    |" Return ``true`` if ``n`` is enclosed in a local scope
    n.parent is GenericFormalObjDecl or
    n is *(any semantic_parent is BasicSubpDecl or SubpBody or TaskBody or
                                  BlockStmt or EntryBody or ProtectedBody)

fun is_local_object(o) =
    |" Return ``true`` if ``o`` represents a local ``ObjectDecl`` or ``ParamSpec``
    o is ParamSpec or ObjectDecl when has_local_scope(o)

@memoized
fun is_in_package_scope(o) =
    |" Return ``true`` if ``o`` is immediately in the scope of a package spec,
    |" body or generic package.
    match o?.parent
    | BasePackageDecl     => true
    | PackageBody         => true
    | SingleTaskDecl      => false
    | TaskTypeDecl        => false
    | TaskBody            => false
    | BlockStmt           => false
    | BaseSubpBody        => false
    | EntryBody           => false
    | SingleProtectedDecl => false
    | ProtectedTypeDecl   => false
    | null                => false
    | *                   => is_in_package_scope(o?.parent)

fun is_program_unit(n) =
    |" Return ``true`` if ``n`` is a program unit spec, body or stub
    n is SubpDecl or AbstractSubpDecl or BaseSubpBody
      or BasePackageDecl or PackageBody or GenericPackageInstantiation
      or GenericDecl or GenericInstantiation
      or SingleTaskDecl or TaskTypeDecl or TaskBody
      or SubpBodyStub or ProtectedBodyStub or PackageBodyStub or TaskBodyStub
      or SingleProtectedDecl or ProtectedTypeDecl

@memoized
fun is_in_library_unit_body(o) =
    |" Return ``true`` if ``o`` is located in a library unit body
    match o?.parent
    | s@SubpBody    => s?.parent is LibraryItem
    | p@PackageBody => p?.parent is LibraryItem
    | null          => false
    | *             => is_in_library_unit_body(o?.parent)

fun param_pos(n, pos: int = 0) =
    |" Return the position of node ``n`` in its current list of siblings
    if not n then pos else param_pos(n?.previous_sibling, pos+1)

# TODO: move this in LAL
fun is_predefined_op(op) =
    |" Return true if op is a predefined operator
{
    val ref = op.p_referenced_decl();
    # TODO: remove null check once all operators are synthesized (UB16-053)
    not ref or ref is SyntheticSubpDecl
}

fun is_standard_numeric(n) =
    |" Return ``true`` if ``n`` is the name of a numeric type or subtype in Standard
    n == "standard.integer" or
    n == "standard.natural" or
    n == "standard.positive" or
    n == "standard.short_short_integer" or
    n == "standard.short_integer" or
    n == "standard.long_integer" or
    n == "standard.long_long_integer" or
    n == "standard.long_long_long_integer" or
    n == "standard.short_float" or
    n == "standard.float" or
    n == "standard.long_float" or
    n == "standard.long_long_float" or
    n == "standard.duration"

fun is_standard_boolean(n) =
    |" Return true if the root type of n is Standard.Boolean
    n.p_expression_type() is t@BaseTypeDecl
    when t.p_root_type() == n.p_bool_type()

fun is_predefined_type(n) =
    |" Return true if n is the name of a type declared in a predefined package
    |" spec.
{
    # Retrieve the root enclosing package
    # TODO: replace p_full_view() by new LAL API once U915-027 is implemented
    val packages = [
        p for p in n.p_referenced_decl().p_root_type().p_full_view().
                    p_root_type().parents(include_self=false)
        if p is BasePackageDecl
    ].to_list;

    packages and packages[packages.length] is
        BasePackageDecl(f_package_name is
                        DefiningName(p_canonical_part() is name@DefiningName))
        when name.p_name_is("Standard")
          or name.p_name_is("System")
          or name.p_name_is("Ada")
          or name.p_name_is("Interfaces")
}

fun in_generic_template(n) =
    |" Return true if ``n`` is declared as part of a generic template (spec
    |" or body). Return false otherwise, including inside a generic
    |" instantiation.
    n and
    not n.p_generic_instantiations() and
    ((n is *(any parent is GenericDecl)) or
     n is *(any parent is PackageBody(p_decl_part() is GenericPackageInternal)))

fun enclosing_block(n) =
    |" Return the first DeclBlock enclosing n if any, null otherwise
{
    val block = [p for p in n.parents(include_self=false)
                  if p is DeclBlock]?[1];
    if block then block else null
}

@memoized
fun enclosing_body(n) =
    |" Return the first Body enclosing n if any, null otherwise
{
    val body = [p for p in n.parents(include_self=false)
                  if p is Body]?[1];
    if body then body else null
}

@memoized
fun enclosing_package(n) =
    |" Return the first BasePackageDecl or PackageBody enclosing n if any,
    |" null otherwise
{
    val pkg = [p for p in n.parents(include_self=false)
                  if p is BasePackageDecl or PackageBody]?[1];
    if pkg then pkg else null
}

# TODO: move to LAL
fun is_classwide_type(t) =
    |" Return true if t is a classwide TypeDecl.
    t is ClasswideTypeDecl or
         BaseSubtypeDecl(p_base_subtype() is ClasswideTypeDecl)

# TODO: move to LAL
fun is_controlling_param_type(t, spec) =
    |" Return true if `t` is a TypeExpr corresponding to a controlling
    |" parameter of the subprogram spec `spec`.
    t is TypeExpr(p_designated_type_decl() is d@BaseTypeDecl)
    when ((d.p_is_tagged_type() and not is_classwide_type(d)) or
          (d is AnonymousTypeDecl and
           d.p_accessed_type()?.p_is_tagged_type() and
           not is_classwide_type(d.p_accessed_type())))
     # Check that t is in the same package decl as spec
     and (enclosing_package(t) == enclosing_package(spec))

# TODO: move to LAL?
fun is_constructor(spec) =
    |" Return true if spec is a subprogram spec of a constructor, that is, has
    |" a controlling result and no controlling parameter.
    is_controlling_param_type(spec.p_returns(), spec)
     and not [p for p in spec.p_params()
              if is_controlling_param_type(p.f_type_expr, spec)]

fun is_constant_object(node) =
    |" Return true is node represents a constant object, false otherwise
    node is ObjectDecl or ParamSpec and node.p_is_constant_object()

@memoized
fun get_subp_body(node) =
    |" Return the SubpBody or TaskBody corresponding to node, if any, null
    |" otherwise.
    match node
    | SubpRenamingDecl =>
        get_subp_body(node.f_renames.f_renamed_object.p_referenced_decl())
    | BaseSubpBody     => node
    | EnumLiteralDecl  => null
    | ClassicSubpDecl  => node.p_body_part()
    | GenericSubpInstantiation
                       => node.p_designated_generic_decl().p_body_part()
    | SubpBodyStub     => node.p_body_part_for_decl()
    | EntryDecl        =>
        # For a task entry decl, return the task body as an over approximation
        # TODO: replace p_next_part_for_decl once U920-016 if fixed.
        (match node.p_semantic_parent()
         | d@SingleTaskTypeDecl => d.parent.p_next_part_for_decl()
         | d@TaskTypeDecl       => d.p_next_part_for_decl()
         | *                    => node.p_body_part())
    | TaskTypeDecl     => node.p_next_part_for_decl()
    | BasicDecl when node.p_is_subprogram()
                       => node.p_body_part_for_decl()
    | *                => null

fun is_limited_type(type) =
    |" Return `true` if type is a limited type
    type.f_type_def is
        (def@(DerivedTypeDef or PrivateTypeDef or RecordTypeDef)
         when def.f_has_limited.p_as_bool()) or
    InterfaceTypeDef(f_interface_kind is InterfaceKindLimited)

@memoize
fun list_of_units() =
    |" Return a (cached) list of all known units
    units().to_list

fun sloc_image(node) =
    |" Return a string with basename:line corresponding to node's sloc
{
    val tok = node.token_start();
    tok.unit.name.base_name & ":" & img(tok.start_line)
}

fun find_comment(token, name) =
    |" Return true if a comment token immediately following the previous
    |" "begin" keyword is found and containing only the package name.
    if token.kind == "ADA_COMMENT" and
       token.previous.previous.kind == "ADA_BEGIN"
    then token.text.ends_with(name) and
         match token.text.substring(1, token.text.length - name.length)
         | "^-- *$" => true
         | *        => false
    else token.kind != "ADA_BEGIN" and find_comment(token.previous, name)

fun first_non_blank(s, ind=1) =
    |" Return the index of the first non blank character of s, starting at ind
    match s.substring(ind, ind)
    | "[ \t]" => first_non_blank(s, ind + 1)
    | *       => ind

fun next_non_blank_token_line(token) =
    |" Return the start line of the next non blank token, or the next line for
    |" a comment, or 0 if none.
{
    val n = token.next;
    match n.kind
    | "ADA_WHITESPACE" => next_non_blank_token_line(n)
    | "ADA_COMMENT"    => n.start_line + 1
    | "NO_TOKEN"       => 0
    | *                => n.start_line
}

fun previous_non_blank_token_line(token) =
    |" Return the end line of the previous non blank token, or the previous
    |" line for a comment, or 0 if none.
{
    val p = token.previous;
    match p.kind
    | "ADA_WHITESPACE" => previous_non_blank_token_line(p)
    | "ADA_COMMENT"    => p.start_line - 1
    | "NO_TOKEN"       => 0
    | *                => p.end_line
}

fun max(x, y) =
    |" Return the max value between x and y
    if x > y then x else y

fun int_value(expr) =
    |" Return the integer value corresponding to expr if expr is a static
    |" expression, 0 otherwise.
    if expr.p_is_static_expr() then expr.p_eval_as_int() else 0

fun range_values(left, right) =
    |" Return the number of values covered between left and right expressions,
    |" 0 if it cannot be determined.
    max(int_value(right) - int_value(left) + 1, 0)

fun number_of_values(type) =
    |" Return the number of values covered by a given BaseTypeDecl, 0 if
    |" this value cannot be determined.
{
    fun count_values_def(def) =
    match def
    | EnumTypeDef           => def.f_enum_literals.children_count
    | ModIntTypeDef         => int_value(def.f_expr)
    | SignedIntTypeDef
      when def.f_range.f_range is op@BinOp(f_op is OpDoubleDot) =>
        range_values(op.f_right, op.f_left)
    | DerivedTypeDef        =>
        if def.f_subtype_indication.f_constraint is r@RangeConstraint
        then (if r.f_range.f_range is op@BinOp
              then range_values(op.f_left, op.f_right) else 0)
        else number_of_values(def.f_subtype_indication.f_name.p_referenced_decl())
    | FormalDiscreteTypeDef => 0
    | *                     => 0;

    if type is SubtypeDecl
    then (if type.f_subtype.f_constraint is r@RangeConstraint
          then (if r.f_range.f_range is op@BinOp
                then range_values(op.f_left, op.f_right) else 0)
          else number_of_values(type.f_subtype.f_name.p_referenced_decl()))
    else count_values_def(type.f_type_def)
}
