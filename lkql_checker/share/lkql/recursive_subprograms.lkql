# Flags specs (and bodies that act as specs) of recursive subprograms. A
# subprogram is considered as recursive in a given context if there exists a
# chain of direct calls starting from the body of, and ending at this
# subprogram within this context. A context is provided by the set of Ada
# sources specified as arguments of a given gnatcheck call. Neither dispatching
# calls nor calls through access-to-subprograms are considered as direct calls
# by this rule. If Skip_Dispatching_Calls is not set, gnatcheck considers a
# dispatching call as a set of calls to all the subprograms the dispatching
# call may dispatch to.
#
# This rule does not take into account calls that may happen as the result of
# subprogram import or more generally unavailable subprogram bodies. See rule
# Unavailable_Body_Calls to detect these cases.
#
# Generic subprograms and subprograms detected in generic units are not flagged.
# Recursive subprograms in expanded generic instantiations are flagged.
#
# This rule does not take into account subprogram calls in aspect definitions
# nor (for now) implicit calls made via type initialization.
#
# The rule has a parameter Skip_Dispatching_Calls: Do not take into account
# dispatching calls when building and analyzing call chains.

import stdlib

# Get the bodies of the functions called statically by a given function body
@memoized
selector static_calls
    | b@Body => rec *
        # Grab the bodies for every static call
        [stdlib.get_subp_body(a.p_referenced_decl())
         for a in stdlib.children_no_nested_subps(b)
         if a is BaseId
         when a.p_is_static_call() or
              a.p_referenced_decl() is TaskTypeDecl].to_list
    | *      => ()

@memoized
fun my_units() = 
    if skip_dispatching_calls then [] else units().to_list

# Given a `name`, return all the bodies of the decl referenced by `name`,
# taking dispatching calls into account.
fun bodies(name) =
    if name is Expr(p_is_dispatching_call() is true) then {
        val root  = name.p_referenced_decl().p_canonical_part();
        val roots = root.p_root_subp_declarations();
        val subp  = if roots.length == 0 then root else roots[1];
        [stdlib.get_subp_body(subp)] &
        [s.p_body_part() for s in subp.p_find_all_overrides(my_units())].to_list
    } else [stdlib.get_subp_body(name.p_referenced_decl())]

fun calls_helper(b) = 
      concat([bodies(a) for a in stdlib.children_no_nested_subps(b)
              if a is BaseId
              when a.p_is_direct_call() or
                   a.p_referenced_decl() is TaskTypeDecl].to_list)

@memoized
selector calls
   | b@Body => rec * calls_helper(b)
       # Grab the bodies for every direct call
   | *      => ()

@check(message="recursive subprogram",
       follow_generic_instantiations=true)
fun recursive_subprograms(node, skip_dispatching_calls=false) =
    node is (ClassicSubpDecl or
             BaseSubpBody(p_previous_part() is null or GenericSubpDecl))
    when (not stdlib.in_generic_template(node))
     and stdlib.get_subp_body(node) is b@BaseSubpBody when
         if skip_dispatching_calls
         then b is body@BaseSubpBody(any static_calls is c@BaseSubpBody
                                     when body == c)
         else b is body@BaseSubpBody(any calls is c@BaseSubpBody when body == c)
