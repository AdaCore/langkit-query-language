# Flags specs (and bodies that act as specs) of recursive subprograms. A
# subprogram is considered as recursive in a given context if there exists a
# chain of direct calls starting from the body of, and ending at this
# subprogram within this context. A context is provided by the set of Ada
# sources specified as arguments of a given gnatcheck call. Neither dispatching
# calls nor calls through access-to-subprograms are considered as direct calls
# by this rule. If Skip_Dispatching_Calls is not set, gnatcheck considers a
# dispatching call as a set of calls to all the subprograms the dispatching
# call may dispatch to.
#
# This rule does not take into account calls that may happen as the result of
# subprogram import or more generally unavailable subprogram bodies. See rule
# Unavailable_Body_Calls to detect these cases.
#
# Generic subprograms and subprograms detected in generic units are not flagged.
# Recursive subprograms in expanded generic instantiations are flagged.
#
# This rule does not take into account subprogram calls in aspect definitions
# nor (for now) implicit calls made via type initialization.
#
# The rule has a parameter Skip_Dispatching_Calls: Do not take into account
# dispatching calls when building and analyzing call chains.

import stdlib

# Get the bodies of the functions called statically by a given function body
selector static_calls
    | b@Body => rec *
        # Grab the bodies for every static call
        [stdlib.get_subp_body(a.p_referenced_decl())
         for a in stdlib.children_no_nested_subps(b)
         if a is not CallExpr and a is Name(p_is_static_call() is true)].to_list
    | *      => ()

@check(message="recursive subprogram",
       follow_generic_instantiations=true)
fun recursive_subprograms(node, skip_dispatching_calls=false) = {
    val units = if skip_dispatching_calls then [] else units().to_list;

    # Given a `name`, return all the bodies of the decl referenced by `name`,
    # taking dispatching calls into account.
    fun bodies(name) =
        if name is Expr(p_is_dispatching_call() is true) then {
            val root  = name.p_referenced_decl()?.p_canonical_part();
            val roots = root?.p_root_subp_declarations();
            val subp  = if roots.length == 0 then root else roots[1];
            [stdlib.get_subp_body(subp)] &
            [s.p_body_part() for s in subp.p_find_all_overrides(units)].to_list
        } else [stdlib.get_subp_body(name.p_referenced_decl())];

    # Get the bodies of the functions called statically or via dispatching by a
    # given function body
    selector calls
    | b@Body => rec *
        # Grab the bodies for every direct call
        concat([bodies(a) for a in stdlib.children_no_nested_subps(b)
                if a is not CallExpr and a is Name(p_is_direct_call() is true)].
               to_list)
    | *      => ();

    # Check the given BaseSubpBody `b` for recursivity
    fun check_body(b, skip_dispatching_calls) =
        if skip_dispatching_calls
        then b is BaseSubpBody(any static_calls is c@BaseSubpBody when b == c)
        else b is BaseSubpBody(any calls is c@BaseSubpBody when b == c);

    node is (ClassicSubpDecl or GenericSubpInstantiation or
             BaseSubpBody(p_previous_part() is null))
    when (not stdlib.in_generic_template(node))
     and check_body(stdlib.get_subp_body(node), skip_dispatching_calls)
}
