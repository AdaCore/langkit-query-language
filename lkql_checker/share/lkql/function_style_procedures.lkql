# Flag each procedure that can be rewritten as a function. A procedure can be
# converted into a function if it has exactly one parameter of mode out, no
# parameters of mode in out and no Global aspect or an explicit Global => null.
# Procedure declarations, formal procedure declarations, and generic procedure
# declarations are always checked.
# Procedure bodies and body stubs are flagged only if they do not have
# corresponding separate declarations. Procedure renamings and procedure
# instantiations are not flagged.
# If a procedure can be rewritten as a function, but its out parameter is of a
# limited type, it is not flagged.
# Protected procedures are not flagged. Null procedures also are not flagged.

fun in_out_params(s) =
    [p for p in s.p_params() if p.f_mode is ModeInOut]

fun params_out(s) =
    [p for p in s.p_params() if p.f_mode is ModeOut].to_list

fun is_limited(t) = t.f_has_limited.p_as_bool()

@check(message="procedure can be rewritten as function", category="Feature")
fun function_style_procedures(node) =
    node is (SubpBody or SubpBodyStub or ClassicSubpDecl or GenericSubpInternal)
    when (node is (ClassicSubpDecl or GenericSubpInternal) or
          not node.p_previous_part())
     and node.f_subp_spec.f_subp_kind is SubpKindProcedure
     and node.p_get_aspect_spec_expr("Global") is null or NullLiteral
     and not in_out_params(node.f_subp_spec)
     and ({
         # Check for 1 out parameter of a non limited type
         val p_out=params_out(node.f_subp_spec);
         p_out.length == 1 and
         p_out[1].f_ids.children_count == 1 and
         p_out[1].f_type_expr.p_designated_type_decl() is not
             TypeDecl(f_type_def is
                          (def@(DerivedTypeDef or PrivateTypeDef or
                                RecordTypeDef)
                          when def.f_has_limited.p_as_bool())
                       or InterfaceTypeDef(f_interface_kind is
                                           InterfaceKindLimited))})
