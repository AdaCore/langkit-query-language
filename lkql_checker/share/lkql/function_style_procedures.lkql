# Flag each procedure that can be rewritten as a function. A procedure can be
# converted into a function if it has exactly one parameter of mode out, no
# parameters of mode in out and no Global aspect or an explicit Global => null.
# Procedure declarations, formal procedure declarations, and generic procedure
# declarations are always checked.
# Procedure bodies and body stubs are flagged only if they do not have
# corresponding separate declarations. Procedure renamings and procedure
# instantiations are not flagged.
# If a procedure can be rewritten as a function, but its out parameter is of a
# limited type, it is not flagged.
# Protected procedures are not flagged. Null procedures also are not flagged.

fun params_in_out(s) =
    [p for p in s?.p_params() if p?.f_mode is ModeInOut]

fun params_out(s) =
    [p for p in s?.p_params() if p?.f_mode is ModeOut]

fun is_limited(t) = t?.f_has_limited?.p_as_bool()

@check(message="procedure can be rewritten as function")
fun function_style_procedures(node) =
    node is SubpDecl(f_subp_spec is SubpSpec(f_subp_kind is SubpKindProcedure),
                     p_get_aspect_spec_expr("Global") is null or NullLiteral)
    when params_in_out(node.f_subp_spec).length == 0
     and ({
         # Check for 1 out parameter of a non limited type
         val p_out=params_out(node.f_subp_spec);
         p_out.length == 1
         and [p for p in p_out
              if p?.f_type_expr?.p_designated_type_decl() is
                 TypeDecl(f_type_def is
                          t@(DerivedTypeDef or PrivateTypeDef or RecordTypeDef)
                          when is_limited(t))].length == 0})
