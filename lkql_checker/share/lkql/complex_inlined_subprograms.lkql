# Flag a subprogram (or generic subprogram, or instantiation of a subprogram)
# if pragma Inline is applied to it and at least one of the following
# conditions is met:
# - it contains at least one complex declaration such as a subprogram body,
#   package, task, protected declaration, or a generic instantiation (except
#   instantiation of Ada.Unchecked_Conversion);
# - it contains at least one complex statement such as a loop, a case or an if
#   statement;
# - the number of statements exceeds a value specified by the N rule parameter;
# Subprogram renamings are also considered.

import stdlib

@memoized
fun complex_declaration(decls) =
    |" Return the first complex declaration found in decls, null otherwise
    from decls
    select first SubpBody or PackageDecl or TaskBody or ProtectedBody
    or GenericPackageInstantiation
    or (node@GenericSubpInstantiation
        when not stdlib.is_unchecked_conversion(node))

@memoized
fun complex_statement(stmts) =
    |" Return the first complex statement found in stmts, null otherwise
    from stmts select first BaseLoopStmt or CaseStmt or IfStmt

fun is_complex_subp(node, n) =
    |" Return true is node is a complex subprogram body as defined above
    node is SubpBody and
    (complex_declaration(node.f_decls) or
     complex_statement(node.f_stmts) or
     # Check for number of statements
     [s for s in node?.f_stmts?.f_stmts?.children if s is Stmt].length > n)

@unit_check(help="complex inlined subprograms", category="Feature")
fun complex_inlined_subprograms(unit, n : int = 5) = [
    {message: match complex_declaration(stdlib.get_subp_body(nod)?.f_decls)
              | decl@AdaNode => (
                  "complex declaration in inlined subprogram (line " &
                  img(decl?.token_start().start_line) & ")"
                )
              | *            => (
                  match complex_statement(stdlib.get_subp_body(nod)?.f_stmts)
                  | stmt@Stmt => "branching in inlined subprogram (line " &
                                 img(stmt?.token_start().start_line) & ")"
                  | *         => "too many statements in inlined subprogram"
                ),
     loc: if nod is SubpRenamingDecl then stdlib.get_subp_body(nod) else nod}
    for nod in from unit.root
    select node@(SubpBody or GenericSubpInstantiation or SubpRenamingDecl)
    when node.p_has_aspect("Inline")
     and is_complex_subp(stdlib.get_subp_body(node), n)]
